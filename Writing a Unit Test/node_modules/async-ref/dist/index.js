var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);
var __accessCheck = (obj, member, msg) => {
  if (!member.has(obj))
    throw TypeError("Cannot " + msg);
};
var __privateGet = (obj, member, getter) => {
  __accessCheck(obj, member, "read from private field");
  return getter ? getter.call(obj) : member.get(obj);
};
var __privateAdd = (obj, member, value) => {
  if (member.has(obj))
    throw TypeError("Cannot add the same private member more than once");
  member instanceof WeakSet ? member.add(obj) : member.set(obj, value);
};
var __privateSet = (obj, member, value, setter) => {
  __accessCheck(obj, member, "write to private field");
  setter ? setter.call(obj, value) : member.set(obj, value);
  return value;
};

// src/index.ts
var src_exports = {};
__export(src_exports, {
  createAsyncRef: () => createAsyncRef
});
module.exports = __toCommonJS(src_exports);

// src/async-ref.ts
var _promise, _notify, _frozen, _state, _resolve, _reject;
var AsyncMutableRefObject = class {
  constructor(notify = () => {
  }) {
    __privateAdd(this, _promise, void 0);
    __privateAdd(this, _notify, void 0);
    __privateAdd(this, _frozen, false);
    __privateAdd(this, _state, {
      status: 0 /* Loading */,
      value: null,
      error: null
    });
    __privateAdd(this, _resolve, (value) => {
      __privateSet(this, _state, { status: 1 /* Success */, value, error: null });
      __privateGet(this, _notify).call(this);
    });
    __privateAdd(this, _reject, (error) => {
      __privateSet(this, _state, { status: 2 /* Error */, value: null, error });
      __privateGet(this, _notify).call(this);
    });
    __privateSet(this, _notify, notify);
    __privateSet(this, _promise, new Promise((resolve, reject) => {
      if (__privateGet(this, _state).status === 1 /* Success */) {
        resolve(__privateGet(this, _state).value);
        return;
      } else if (__privateGet(this, _state).status === 2 /* Error */) {
        reject(__privateGet(this, _state).error);
        return;
      }
      const derefResolve = __privateGet(this, _resolve);
      const derefReject = __privateGet(this, _reject);
      __privateSet(this, _resolve, (value) => {
        derefResolve(value);
        resolve(value);
      });
      __privateSet(this, _reject, (error) => {
        derefReject(error);
        reject(error);
      });
    }));
  }
  get current() {
    switch (__privateGet(this, _state).status) {
      case 0 /* Loading */:
        throw __privateGet(this, _promise);
      case 1 /* Success */:
        return __privateGet(this, _state).value;
      case 2 /* Error */:
        throw __privateGet(this, _state).error;
    }
  }
  set current(value) {
    __privateGet(this, _resolve).call(this, value);
  }
  then(onfulfilled, onrejected) {
    return __privateGet(this, _promise).then(() => this.current, () => this.current).then(onfulfilled, onrejected);
  }
  resolve(value) {
    __privateGet(this, _resolve).call(this, value);
    return this;
  }
  reject(error) {
    __privateGet(this, _reject).call(this, error);
    return this;
  }
  freeze() {
    __privateSet(this, _frozen, true);
    __privateSet(this, _resolve, () => {
    });
    __privateSet(this, _reject, () => {
    });
    return this;
  }
  isFrozen() {
    return __privateGet(this, _frozen);
  }
};
_promise = new WeakMap();
_notify = new WeakMap();
_frozen = new WeakMap();
_state = new WeakMap();
_resolve = new WeakMap();
_reject = new WeakMap();
var createAsyncRef = (notify = () => {
}) => {
  return new AsyncMutableRefObject(notify);
};
// Annotate the CommonJS export names for ESM import in node:
0 && (module.exports = {
  createAsyncRef
});
//# sourceMappingURL=index.js.map