var __create = Object.create;
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", { value: mod, enumerable: true }) : target, mod));
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);
var __accessCheck = (obj, member, msg) => {
  if (!member.has(obj))
    throw TypeError("Cannot " + msg);
};
var __privateGet = (obj, member, getter) => {
  __accessCheck(obj, member, "read from private field");
  return getter ? getter.call(obj) : member.get(obj);
};
var __privateAdd = (obj, member, value) => {
  if (member.has(obj))
    throw TypeError("Cannot add the same private member more than once");
  member instanceof WeakSet ? member.add(obj) : member.set(obj, value);
};
var __privateSet = (obj, member, value, setter) => {
  __accessCheck(obj, member, "write to private field");
  setter ? setter.call(obj, value) : member.set(obj, value);
  return value;
};

// src/index.ts
var src_exports = {};
__export(src_exports, {
  AbstractBackend: () => AbstractBackend,
  AlwaysBackend: () => AlwaysBackend,
  ComputedBackend: () => ComputedBackend,
  NullBackend: () => NullBackend,
  StaticBackend: () => StaticBackend,
  createFlags: () => createFlags
});
module.exports = __toCommonJS(src_exports);

// src/create-flags.tsx
var import_react = __toESM(require("react"));
var MISSING_CONTEXT = Symbol();
var NOOP = () => null;
var isFlagScalar = (value) => {
  return typeof value === "string" || typeof value === "number" || typeof value === "boolean";
};
var createFlags = () => {
  const calleeStr = (keyPath, defaultValue, format) => () => {
    const keyPathStr = JSON.stringify(keyPath);
    const defaultValueStr = JSON.stringify(defaultValue);
    return format == "hook" ? `useFlag(${keyPathStr}, ${defaultValueStr})` : `<Flag keyPath=${keyPathStr} defaultValue=${defaultValueStr} ... />`;
  };
  const Context = import_react.default.createContext(MISSING_CONTEXT);
  Context.displayName = "Flag";
  const FlagBackendProvider = ({ backend, children }) => {
    return /* @__PURE__ */ import_react.default.createElement(Context.Provider, {
      value: backend
    }, children);
  };
  FlagBackendProvider.displayName = "FlagBackendProvider";
  const internalUseFlag = (keyPath, defaultValue, displayCallee) => {
    const keyPath_ = Array.isArray(keyPath) ? keyPath : keyPath.split(".");
    if (defaultValue === void 0) {
      throw new Error(`Calling \`${displayCallee()}\` requires that you provide a default value that matches the type of the flag.`);
    }
    const expectedType = typeof defaultValue;
    const backend = import_react.default.useContext(Context);
    if (backend === MISSING_CONTEXT) {
      if (process.env.NODE_ENV !== "development") {
        return defaultValue;
      }
      throw new Error(`Calling \`${displayCallee()}\` requires that the application is wrapped in a \`<FlagBackendProvider />\``);
    }
    const ext = backend.toExternalStore(keyPath_, defaultValue);
    let result = import_react.default.useSyncExternalStore(ext.subscribe, ext.getSnapshot, ext.getServerSnapshot);
    if ((result === void 0 || result === null) && process.env.NODE_ENV === "development") {
      console.warn(`\`${displayCallee()}\` does not return anything from backend "${backend.name}".`);
    }
    result != null ? result : result = defaultValue;
    if (!isFlagScalar(result)) {
      throw new Error(`Calling \`${displayCallee()}\` requires that the result is a boolean, number or string. Instead returned ${JSON.stringify(result)}.`);
    }
    if (typeof result !== expectedType) {
      if (process.env.NODE_ENV === "development") {
        console.warn(`Expected result of \`${displayCallee()}\` to be a ${expectedType} (based on the default value of ${JSON.stringify(defaultValue)}). Instead returned ${JSON.stringify(result)}. Falling back to default value.`);
      }
      return defaultValue;
    }
    return result;
  };
  function Flag({ keyPath, defaultValue, render, fallback }) {
    fallback != null ? fallback : fallback = NOOP;
    const flag = internalUseFlag(keyPath, defaultValue, calleeStr(keyPath, defaultValue, "component"));
    return flag === false ? fallback() : render(flag);
  }
  Flag.displayName = "Flag";
  function useFlag(keyPath, defaultValue) {
    import_react.default.useDebugValue(keyPath);
    return internalUseFlag(keyPath, defaultValue, calleeStr(keyPath, defaultValue, "hook"));
  }
  return {
    FlagBackendProvider,
    Flag,
    useFlag
  };
};

// src/backends/abstract-backend.ts
var import_async_ref = require("async-ref");
var _listeners, _subscribe;
var AbstractBackend = class {
  constructor() {
    this.notify = () => __privateGet(this, _listeners).forEach((sub) => sub());
    __privateAdd(this, _listeners, /* @__PURE__ */ new Set());
    __privateAdd(this, _subscribe, (sub) => {
      __privateGet(this, _listeners).add(sub);
      return () => __privateGet(this, _listeners).delete(sub);
    });
  }
  getServerSnapshot(keyPath, defaultValue) {
    return this.getSnapshot(keyPath, defaultValue);
  }
  get name() {
    return this.constructor.name;
  }
  toExternalStore(keyPath, defaultValue) {
    const subscribe = __privateGet(this, _subscribe);
    const getSnapshot = () => this.getSnapshot(keyPath, defaultValue);
    const getServerSnapshot = () => this.getServerSnapshot(keyPath, defaultValue);
    return {
      subscribe,
      getSnapshot,
      getServerSnapshot
    };
  }
  createAsyncRef() {
    return (0, import_async_ref.createAsyncRef)(this.notify);
  }
};
_listeners = new WeakMap();
_subscribe = new WeakMap();

// src/backends/always-backend.ts
var _alwaysMapping;
var AlwaysBackend = class extends AbstractBackend {
  constructor(alwaysMapping = {}) {
    super();
    __privateAdd(this, _alwaysMapping, void 0);
    __privateSet(this, _alwaysMapping, alwaysMapping);
  }
  getSnapshot(keyPath, defaultValue) {
    var _a;
    const type = typeof defaultValue;
    if (type !== "boolean" && type !== "string" && type !== "number") {
      throw new Error(`AlwaysBackend: dafault value must be a boolean, string or number, but got ${type}`);
    }
    return (_a = __privateGet(this, _alwaysMapping)[type]) != null ? _a : defaultValue;
  }
};
_alwaysMapping = new WeakMap();

// src/backends/static-backend.ts
var _data;
var StaticBackend = class extends AbstractBackend {
  constructor(data) {
    super();
    __privateAdd(this, _data, void 0);
    __privateSet(this, _data, data);
  }
  getSnapshot(keyPath, defaultValue) {
    if (keyPath.length === 0) {
      return defaultValue;
    }
    let result = __privateGet(this, _data);
    for (const key of keyPath) {
      result = result[key];
      if (result === void 0) {
        return defaultValue;
      }
    }
    return result;
  }
};
_data = new WeakMap();

// src/backends/computed-backend.ts
var makeComputable = (data, getRoot) => {
  if (typeof data !== "object") {
    return data;
  }
  return new Proxy(data, {
    get: (target, key_) => {
      const key = key_;
      const next = target[key];
      if (typeof next === "function") {
        const root = getRoot();
        return makeComputable(next(root), getRoot);
      }
      return makeComputable(next, getRoot);
    }
  });
};
var ComputedBackend = class extends StaticBackend {
  constructor(data) {
    const computable = makeComputable(data, () => computable);
    super(computable);
  }
};

// src/backends/null-backend.ts
var NullBackend = class extends AbstractBackend {
  getSnapshot(keyPath, defaultValue) {
    return defaultValue;
  }
};
// Annotate the CommonJS export names for ESM import in node:
0 && (module.exports = {
  AbstractBackend,
  AlwaysBackend,
  ComputedBackend,
  NullBackend,
  StaticBackend,
  createFlags
});
//# sourceMappingURL=index.js.map