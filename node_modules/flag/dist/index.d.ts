import { AsyncMutableRefObject } from 'async-ref';
import React from 'react';

declare type Join<KP extends any[]> = KP extends [infer A] ? A extends string ? A : never : KP extends [infer A, ...infer B] ? A extends string ? `${A}.${Join<B>}` : never : never;
declare type Split<KP extends string> = KP extends `${infer A}.${infer B}` ? [A, ...Split<B>] : [KP];
declare type FlagScalar = string | number | boolean;
declare type Flags = {
    [key: string]: FlagScalar | Flags;
};
declare type KeyPath<T> = {
    [Key in keyof T & string]: T[Key] extends object ? [Key, ...KeyPath<T[Key]>] : [Key];
}[keyof T & string];
declare type KeyPathString<T> = Join<KeyPath<T>>;
declare type Subscriber = () => void;
declare type Unsubscribe = () => void;
declare type Notifier = () => void;
declare type ExternalStore<T> = {
    getSnapshot(): T;
    getServerSnapshot(): T;
    subscribe(sub: Subscriber): Unsubscribe;
};
declare type GetValueFromKeyPath<T, KP extends KeyPath<T>> = KP extends [infer K, ...infer Rest] ? GetValueFromKeyPath<T[K], Rest> : T extends FlagScalar ? T : never;
declare type GetValueFromKeyPathString<T, KP extends Join<KeyPath<T>>> = Split<KP> extends KeyPath<T> ? GetValueFromKeyPath<T, Split<KP>> : never;

interface Backend<F> {
    name: string;
    getSnapshot<KP extends KeyPath<F>, T extends GetValueFromKeyPath<F, KP>>(keyPath: KP, defaultValue: T): T;
    getServerSnapshot<KP extends KeyPath<F>, T extends GetValueFromKeyPath<F, KP>>(keyPath: KP, defaultValue: T): T;
    toExternalStore<KP extends KeyPath<F>, T extends GetValueFromKeyPath<F, KP>>(keyPath: KP, defaultValue: T): ExternalStore<T>;
}

declare abstract class AbstractBackend<F> implements Backend<F> {
    #private;
    abstract getSnapshot<KP extends KeyPath<F>, T extends GetValueFromKeyPath<F, KP>>(keyPath: KP, defaultValue: T): T;
    getServerSnapshot<KP extends KeyPath<F>, T extends GetValueFromKeyPath<F, KP>>(keyPath: KP, defaultValue: T): T;
    notify: Notifier;
    get name(): string;
    toExternalStore<KP extends KeyPath<F>, T extends GetValueFromKeyPath<F, KP>>(keyPath: KP, defaultValue: T): ExternalStore<T>;
    protected createAsyncRef<T>(): AsyncMutableRefObject<T>;
}

declare type AlwaysMapping = {
    boolean: boolean;
    string: string;
    number: number;
};
declare class AlwaysBackend<F> extends AbstractBackend<F> {
    #private;
    constructor(alwaysMapping?: Partial<AlwaysMapping>);
    getSnapshot<KP extends KeyPath<F>, T extends GetValueFromKeyPath<F, KP>>(keyPath: KP, defaultValue: T): T;
}

declare class StaticBackend<F> extends AbstractBackend<F> {
    #private;
    constructor(data: Partial<F>);
    getSnapshot<KP extends KeyPath<F>, T extends GetValueFromKeyPath<F, KP>>(keyPath: KP, defaultValue: T): T;
}

declare type RecursiveComputable<T, Root> = {
    [K in keyof T]: T[K] extends object ? RecursiveComputable<T[K], Root> : T[K] | ((arg: Root) => T[K]);
};
declare type Computable<T> = RecursiveComputable<T, T>;
declare class ComputedBackend<F> extends StaticBackend<F> {
    constructor(data: Computable<F>);
}

declare class NullBackend<F> extends AbstractBackend<F> {
    getSnapshot<KP extends KeyPath<F>, T extends GetValueFromKeyPath<F, KP>>(keyPath: KP, defaultValue: T): T;
}

declare const createFlags: <F extends Flags>() => {
    FlagBackendProvider: React.FC<React.PropsWithChildren<{
        backend: Backend<F>;
    }>>;
    Flag: {
        <K extends Join<KeyPath<F>>>(props: {
            keyPath: K;
            defaultValue: GetValueFromKeyPathString<F, K>;
            render(value: GetValueFromKeyPathString<F, K>): React.ReactNode;
            fallback?(): React.ReactNode;
        }): JSX.Element;
        <KP extends KeyPath<F>>(props: {
            keyPath: KP;
            defaultValue: GetValueFromKeyPath<F, KP>;
            render(value: GetValueFromKeyPath<F, KP>): React.ReactNode;
            fallback?(): React.ReactNode;
        }): JSX.Element;
        displayName: string;
    };
    useFlag: {
        <K_1 extends Join<KeyPath<F>>>(keyPath: K_1, defaultValue: GetValueFromKeyPathString<F, K_1>): GetValueFromKeyPathString<F, K_1>;
        <KP_1 extends KeyPath<F>>(keyPath: KP_1, defaultValue: GetValueFromKeyPath<F, KP_1>): GetValueFromKeyPath<F, KP_1>;
    };
};

declare type KeyPath_<T> = KeyPath<T>;
declare type KeyPathString_<T> = KeyPathString<T>;
declare type GetValueFromKeyPath_<T, KP extends KeyPath<T>> = GetValueFromKeyPath<T, KP>;
declare type GetValueFromKeyPathString_<T, KP extends KeyPathString<T>> = GetValueFromKeyPathString<T, KP>;
declare type ExternalStore_<T> = ExternalStore<T>;
declare type Backend_<T> = Backend<T>;
declare type AsyncMutableRefObject_<T> = AsyncMutableRefObject<T>;
declare module Types {
    type KeyPath<T> = KeyPath_<T>;
    type KeyPathString<T> = KeyPathString_<T>;
    type GetValueFromKeyPath<T, KP extends KeyPath<T>> = GetValueFromKeyPath_<T, KP>;
    type GetValueFromKeyPathString<T, KP extends KeyPathString<T>> = GetValueFromKeyPathString_<T, KP>;
    type ExternalStore<T> = ExternalStore_<T>;
    type Backend<T> = Backend_<T>;
    type AsyncMutableRefObject<T> = AsyncMutableRefObject_<T>;
}

export { AbstractBackend, AlwaysBackend, ComputedBackend, NullBackend, StaticBackend, Types, createFlags };
