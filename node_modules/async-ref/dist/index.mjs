var __accessCheck = (obj, member, msg) => {
  if (!member.has(obj))
    throw TypeError("Cannot " + msg);
};
var __privateGet = (obj, member, getter) => {
  __accessCheck(obj, member, "read from private field");
  return getter ? getter.call(obj) : member.get(obj);
};
var __privateAdd = (obj, member, value) => {
  if (member.has(obj))
    throw TypeError("Cannot add the same private member more than once");
  member instanceof WeakSet ? member.add(obj) : member.set(obj, value);
};
var __privateSet = (obj, member, value, setter) => {
  __accessCheck(obj, member, "write to private field");
  setter ? setter.call(obj, value) : member.set(obj, value);
  return value;
};

// src/async-ref.ts
var _promise, _notify, _frozen, _state, _resolve, _reject;
var AsyncMutableRefObject = class {
  constructor(notify = () => {
  }) {
    __privateAdd(this, _promise, void 0);
    __privateAdd(this, _notify, void 0);
    __privateAdd(this, _frozen, false);
    __privateAdd(this, _state, {
      status: 0 /* Loading */,
      value: null,
      error: null
    });
    __privateAdd(this, _resolve, (value) => {
      __privateSet(this, _state, { status: 1 /* Success */, value, error: null });
      __privateGet(this, _notify).call(this);
    });
    __privateAdd(this, _reject, (error) => {
      __privateSet(this, _state, { status: 2 /* Error */, value: null, error });
      __privateGet(this, _notify).call(this);
    });
    __privateSet(this, _notify, notify);
    __privateSet(this, _promise, new Promise((resolve, reject) => {
      if (__privateGet(this, _state).status === 1 /* Success */) {
        resolve(__privateGet(this, _state).value);
        return;
      } else if (__privateGet(this, _state).status === 2 /* Error */) {
        reject(__privateGet(this, _state).error);
        return;
      }
      const derefResolve = __privateGet(this, _resolve);
      const derefReject = __privateGet(this, _reject);
      __privateSet(this, _resolve, (value) => {
        derefResolve(value);
        resolve(value);
      });
      __privateSet(this, _reject, (error) => {
        derefReject(error);
        reject(error);
      });
    }));
  }
  get current() {
    switch (__privateGet(this, _state).status) {
      case 0 /* Loading */:
        throw __privateGet(this, _promise);
      case 1 /* Success */:
        return __privateGet(this, _state).value;
      case 2 /* Error */:
        throw __privateGet(this, _state).error;
    }
  }
  set current(value) {
    __privateGet(this, _resolve).call(this, value);
  }
  then(onfulfilled, onrejected) {
    return __privateGet(this, _promise).then(() => this.current, () => this.current).then(onfulfilled, onrejected);
  }
  resolve(value) {
    __privateGet(this, _resolve).call(this, value);
    return this;
  }
  reject(error) {
    __privateGet(this, _reject).call(this, error);
    return this;
  }
  freeze() {
    __privateSet(this, _frozen, true);
    __privateSet(this, _resolve, () => {
    });
    __privateSet(this, _reject, () => {
    });
    return this;
  }
  isFrozen() {
    return __privateGet(this, _frozen);
  }
};
_promise = new WeakMap();
_notify = new WeakMap();
_frozen = new WeakMap();
_state = new WeakMap();
_resolve = new WeakMap();
_reject = new WeakMap();
var createAsyncRef = (notify = () => {
}) => {
  return new AsyncMutableRefObject(notify);
};
export {
  createAsyncRef
};
//# sourceMappingURL=index.mjs.map