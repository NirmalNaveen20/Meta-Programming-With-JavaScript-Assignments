{"version":3,"sources":["../src/index.ts","../src/async-ref.ts"],"sourcesContent":["export { createAsyncRef, IAsyncMutableRefObject as AsyncMutableRefObject } from \"./async-ref\";\n","type Notify = () => void;\n\nenum Status {\n  Loading,\n  Success,\n  Error,\n}\n\ntype RefState<T> =\n  | { status: Status.Loading; value: null; error: null }\n  | { status: Status.Success; value: T; error: null }\n  | { status: Status.Error; value: null; error: Error };\n\nexport type IAsyncMutableRefObject<T> = {\n  current: T;\n  resolve(value: T): void;\n  reject(error: Error): void;\n};\n\nclass AsyncMutableRefObject<T> implements IAsyncMutableRefObject<T>, PromiseLike<T> {\n  #promise: Promise<T>;\n  #notify: Notify;\n  #frozen = false;\n  #state: RefState<T> = {\n    status: Status.Loading,\n    value: null,\n    error: null,\n  };\n\n  #resolve = (value: T): void => {\n    this.#state = { status: Status.Success, value, error: null };\n    this.#notify();\n  };\n\n  #reject = (error: Error): void => {\n    this.#state = { status: Status.Error, value: null, error };\n    this.#notify();\n  };\n\n  constructor(notify: Notify = () => {}) {\n    this.#notify = notify;\n\n    this.#promise = new Promise((resolve, reject) => {\n      /**\n       * The AsyncMutableRefObject resolved itself before the callback was invoked.\n       * So here we make sure to still resolve the promise.\n       */\n      if (this.#state.status === Status.Success) {\n        resolve(this.#state.value);\n        return;\n      } else if (this.#state.status === Status.Error) {\n        reject(this.#state.error);\n        return;\n      }\n\n      const derefResolve = this.#resolve;\n      const derefReject = this.#reject;\n\n      /**\n       * If it has not been resolved yet, then wrap the previous #resolve and #reject\n       * to make sure that the promise still resolves itself when called.\n       */\n      this.#resolve = (value) => {\n        derefResolve(value);\n        resolve(value);\n      };\n\n      this.#reject = (error) => {\n        derefReject(error);\n        reject(error);\n      };\n    });\n  }\n\n  public get current(): T {\n    switch (this.#state.status) {\n      case Status.Loading:\n        throw this.#promise;\n      case Status.Success:\n        return this.#state.value;\n      case Status.Error:\n        throw this.#state.error;\n    }\n  }\n\n  public set current(value: T) {\n    this.#resolve(value);\n  }\n\n  public then<TResult1 = T, TResult2 = never>(\n    onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null,\n    onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null\n  ): Promise<TResult1 | TResult2> {\n    return this.#promise\n      .then(\n        () => this.current,\n        () => this.current\n      )\n      .then(onfulfilled, onrejected);\n  }\n\n  public resolve(value: T): AsyncMutableRefObject<T> {\n    this.#resolve(value);\n\n    return this;\n  }\n\n  public reject(error: Error): AsyncMutableRefObject<T> {\n    this.#reject(error);\n\n    return this;\n  }\n\n  public freeze(): AsyncMutableRefObject<T> {\n    this.#frozen = true;\n    this.#resolve = () => {};\n    this.#reject = () => {};\n\n    return this;\n  }\n\n  public isFrozen(): boolean {\n    return this.#frozen;\n  }\n}\n\nexport const createAsyncRef = <T>(notify: Notify = () => {}): AsyncMutableRefObject<T> => {\n  return new AsyncMutableRefObject(notify);\n};\n"],"mappings":";;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAAA;AAAA;AAAA;AAAA;AAAA;;;ACAA;AAmBA,kCAAoF;AAAA,EAoBlF,YAAY,SAAiB,MAAM;AAAA,EAAC,GAAG;AAnBvC;AACA;AACA,gCAAU;AACV,+BAAsB;AAAA,MACpB,QAAQ;AAAA,MACR,OAAO;AAAA,MACP,OAAO;AAAA,IACT;AAEA,iCAAW,CAAC,UAAmB;AAC7B,yBAAK,QAAS,EAAE,QAAQ,iBAAgB,OAAO,OAAO,KAAK;AAC3D,yBAAK,SAAL;AAAA,IACF;AAEA,gCAAU,CAAC,UAAuB;AAChC,yBAAK,QAAS,EAAE,QAAQ,eAAc,OAAO,MAAM,MAAM;AACzD,yBAAK,SAAL;AAAA,IACF;AAGE,uBAAK,SAAU;AAEf,uBAAK,UAAW,IAAI,QAAQ,CAAC,SAAS,WAAW;AAK/C,UAAI,mBAAK,QAAO,WAAW,iBAAgB;AACzC,gBAAQ,mBAAK,QAAO,KAAK;AACzB;AAAA,MACF,WAAW,mBAAK,QAAO,WAAW,eAAc;AAC9C,eAAO,mBAAK,QAAO,KAAK;AACxB;AAAA,MACF;AAEA,YAAM,eAAe,mBAAK;AAC1B,YAAM,cAAc,mBAAK;AAMzB,yBAAK,UAAW,CAAC,UAAU;AACzB,qBAAa,KAAK;AAClB,gBAAQ,KAAK;AAAA,MACf;AAEA,yBAAK,SAAU,CAAC,UAAU;AACxB,oBAAY,KAAK;AACjB,eAAO,KAAK;AAAA,MACd;AAAA,IACF,CAAC;AAAA,EACH;AAAA,MAEW,UAAa;AACtB,YAAQ,mBAAK,QAAO;AAAA,WACb;AACH,cAAM,mBAAK;AAAA,WACR;AACH,eAAO,mBAAK,QAAO;AAAA,WAChB;AACH,cAAM,mBAAK,QAAO;AAAA;AAAA,EAExB;AAAA,MAEW,QAAQ,OAAU;AAC3B,uBAAK,UAAL,WAAc;AAAA,EAChB;AAAA,EAEO,KACL,aACA,YAC8B;AAC9B,WAAO,mBAAK,UACT,KACC,MAAM,KAAK,SACX,MAAM,KAAK,OACb,EACC,KAAK,aAAa,UAAU;AAAA,EACjC;AAAA,EAEO,QAAQ,OAAoC;AACjD,uBAAK,UAAL,WAAc;AAEd,WAAO;AAAA,EACT;AAAA,EAEO,OAAO,OAAwC;AACpD,uBAAK,SAAL,WAAa;AAEb,WAAO;AAAA,EACT;AAAA,EAEO,SAAmC;AACxC,uBAAK,SAAU;AACf,uBAAK,UAAW,MAAM;AAAA,IAAC;AACvB,uBAAK,SAAU,MAAM;AAAA,IAAC;AAEtB,WAAO;AAAA,EACT;AAAA,EAEO,WAAoB;AACzB,WAAO,mBAAK;AAAA,EACd;AACF;AAxGE;AACA;AACA;AACA;AAMA;AAKA;AA4FK,IAAM,iBAAiB,CAAI,SAAiB,MAAM;AAAC,MAAgC;AACxF,SAAO,IAAI,sBAAsB,MAAM;AACzC;","names":[]}